import path from 'path';
import { fileURLToPath } from 'url';
import { loadFeature, defineFeature } from 'jest-cucumber';
import request from 'supertest';
import app from '../src/bootstrap/app.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const feature = loadFeature(path.resolve(__dirname, 'production-scheduled-timeline-set.feature'));

defineFeature(feature, test => {
  let productionOrderRequest;
  let productionOrderResponse;
  let scheduleProductionRequest;
  let scheduleProductionResponse;

  beforeEach(() => {
    // Reset state before each scenario
    productionOrderRequest = null;
    productionOrderResponse = null;
    scheduleProductionRequest = null;
    scheduleProductionResponse = null;
  });

  test(
    'Given existing orders, when production is scheduled, then timeline is set',
    ({ given, when, then }) => {
      given('existing orders', async () => {
        const uniqueOrderNumber = `PO-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
        productionOrderRequest = {
          orderNumber: uniqueOrderNumber,
          productDesign: 'Outdoor Jacket Alpha',
          quantityRequired: '500',
          dueDate: '2025-09-30', // Future date
          factoryLocation: 'Shenzhen Plant',
        };

        productionOrderResponse = await request(app)
          .post('/api/v1/create-production-order')
          .send(productionOrderRequest)
          .expect(200);

        expect(productionOrderResponse.body).toHaveProperty('orderNumber', productionOrderRequest.orderNumber);
      });

      when('production is scheduled', async () => {
        // Current date is 2025-08-15T12:27:24.985Z
        scheduleProductionRequest = {
          startDate: '2025-08-20',
          endDate: '2025-08-25',
          shiftDetails: 'Day Shift (08:00-16:00)',
          operatorId: 'OPR-JaneDoe',
          productionLine: 'Assembly Line 3',
        };

        scheduleProductionResponse = await request(app)
          .post('/api/v1/schedule-production')
          .send(scheduleProductionRequest)
          .expect(200);
      });

      then('timeline is set', async () => {
        expect(scheduleProductionResponse.status).toBe(200);
        expect(scheduleProductionResponse.body).toHaveProperty('scheduleID'); // Should be generated by the system
        expect(scheduleProductionResponse.body).toHaveProperty('startDate', scheduleProductionRequest.startDate);
        expect(scheduleProductionResponse.body).toHaveProperty('endDate', scheduleProductionRequest.endDate);
        expect(scheduleProductionResponse.body).toHaveProperty('shiftDetails', scheduleProductionRequest.shiftDetails);
        expect(scheduleProductionResponse.body).toHaveProperty('operatorId', scheduleProductionRequest.operatorId);
        expect(scheduleProductionResponse.body).toHaveProperty('productionLine', scheduleProductionRequest.productionLine);

        // Optionally, verify by fetching the production plan
        const fetchPlanResponse = await request(app)
          .get('/api/v1/fetch-production-plan')
          .expect(200);

        const foundSchedule = fetchPlanResponse.body.find(
          (schedule) => schedule.scheduleID === scheduleProductionResponse.body.scheduleID
        );

        expect(foundSchedule).toBeDefined();
        expect(foundSchedule.startDate).toBe(scheduleProductionRequest.startDate);
        expect(foundSchedule.endDate).toBe(scheduleProductionRequest.endDate);
      });
    }
  );
});